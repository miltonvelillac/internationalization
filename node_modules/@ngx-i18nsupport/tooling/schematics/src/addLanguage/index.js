"use strict";
/**
 * Schematic to add one or more additional languages to a project using @ngx-i18nsupport.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const schematics_core_1 = require("../../schematics-core");
const common_1 = require("../common");
const common_2 = require("../common");
/*
return rule to change extract script "extract-i18n" to contain newly added languages.
 */
function changeExtractScriptInPackageJson(options, host) {
    // check wether it is changed
    const existingScript = schematics_core_1.getScriptFromPackageJson(host, common_1.extractScriptName);
    const changedScript = common_2.fullExtractScript(options);
    if (existingScript !== changedScript) {
        return (_host, context) => {
            schematics_core_1.addScriptToPackageJson(_host, common_1.extractScriptName, common_2.fullExtractScript(options));
            context.logger.info(`changed npm script to extract i18n message, run "npm run ${common_1.extractScriptName}" for extraction`);
            return _host;
        };
    }
    else {
        return schematics_1.noop();
    }
}
/*
return rule to add language configuration of newly added languages.
 */
function addLanguagesToXliffmergeConfiguration(options, host, languagesToAdd) {
    const xliffmergeJson = readXliffmergeJson(options, host);
    if (xliffmergeJson) {
        const newLanguagesArray = [];
        const languages = xliffmergeJson.xliffmergeOptions.languages;
        if (languages) {
            newLanguagesArray.push(...languages);
        }
        for (const lang of languagesToAdd) {
            if (newLanguagesArray.indexOf(lang) < 0) {
                newLanguagesArray.push(lang);
            }
        }
        xliffmergeJson.xliffmergeOptions.languages = newLanguagesArray;
        return (_host, context) => {
            changeXliffmergeJson(options, _host, xliffmergeJson);
            context.logger.info('changed xliffmerge.json, added languages');
            return _host;
        };
    }
    else {
        return (_host, context) => {
            const msg = 'did not find xliffmerge.conf';
            context.logger.fatal(msg);
            throw new schematics_1.SchematicsException(msg);
        };
    }
}
function readXliffmergeJson(options, host) {
    const path = options.path ? `/${options.path}/xliffmerge.json` : '/xliffmerge.json';
    const content = host.read(path);
    if (!content) {
        return null;
    }
    const contentString = content.toString('UTF-8');
    return JSON.parse(contentString);
}
function changeXliffmergeJson(options, host, xliffmergeJson) {
    const configPath = options.path ? `/${options.path}/xliffmerge.json` : '/xliffmerge.json';
    if (host.exists(configPath)) {
        host.overwrite(configPath, JSON.stringify(xliffmergeJson, null, 2));
    }
    return host;
}
function findConfiguredLanguages(options, host) {
    const result = [];
    // we get it from xliffmerge configuration
    const xliffmergeJson = readXliffmergeJson(options, host);
    if (xliffmergeJson) {
        const languages = xliffmergeJson.xliffmergeOptions.languages;
        if (languages) {
            result.push(...languages);
        }
    }
    return result;
}
/**
 * Sets all options given by commandline or defaults.
 * It also checks values for correctness.
 * @param optionsFromCommandline command line options.
 * @param host the tree to lookup some workspace settings.
 * @param context use for error logging.
 * @return an object where all relevant values are set.
 */
function setupOptions(optionsFromCommandline, host, context) {
    const options = common_1.setupCommonOptions(optionsFromCommandline, host, context);
    // read xliffmerge.json
    const xliffmergeOptions = readXliffmergeJson(options, host);
    if (!xliffmergeOptions) {
        const msg = 'Config file "xliffmerge.json" not found. ' +
            'Please install @ngx-i18nsupport via "ng add @ngx-i18nsupport/tooling" to create it';
        context.logger.fatal(msg);
        throw new schematics_1.SchematicsException(msg);
    }
    if (xliffmergeOptions.xliffmergeOptions.i18nFormat) {
        options.i18nFormat = xliffmergeOptions.xliffmergeOptions.i18nFormat;
    }
    else {
        options.i18nFormat = common_2.defaultI18nFormat;
    }
    if (xliffmergeOptions.xliffmergeOptions.srcDir) {
        options.srcDir = xliffmergeOptions.xliffmergeOptions.srcDir;
    }
    if (xliffmergeOptions.xliffmergeOptions.genDir) {
        options.genDir = xliffmergeOptions.xliffmergeOptions.genDir;
    }
    if (xliffmergeOptions.xliffmergeOptions.defaultLanguage) {
        options.i18nLocale = xliffmergeOptions.xliffmergeOptions.defaultLanguage;
    }
    else {
        options.i18nLocale = common_2.defaultI18nLocale;
    }
    if (optionsFromCommandline.language && optionsFromCommandline.languages) {
        const msg = 'Only language as parameter or --languages can be used, not both.';
        context.logger.fatal(msg);
        throw new schematics_1.SchematicsException(msg);
    }
    if (optionsFromCommandline.language) {
        options.parsedLanguages = [optionsFromCommandline.language];
    }
    else {
        if (!optionsFromCommandline.languages) {
            options.parsedLanguages = [];
        }
        else {
            options.parsedLanguages = optionsFromCommandline.languages.split(',');
        }
    }
    if (options.parsedLanguages.length === 0) {
        const msg = 'At least 1 language must be specified.';
        context.logger.fatal(msg);
        throw new schematics_1.SchematicsException(msg);
    }
    if (options.parsedLanguages.indexOf(options.i18nLocale) >= 0) {
        const msg = `Language "${options.i18nLocale}" is already configured (as default language).`;
        context.logger.fatal(msg);
        throw new schematics_1.SchematicsException(msg);
    }
    options.configuredLanguages = findConfiguredLanguages(options, host);
    // check languages
    for (const lang of options.parsedLanguages) {
        if (options.configuredLanguages.indexOf(lang) >= 0) {
            const msg = `Language "${lang}" is already configured.`;
            context.logger.fatal(msg);
            throw new schematics_1.SchematicsException(msg);
        }
    }
    for (const lang of options.parsedLanguages) {
        if (!common_2.isValidLanguageSyntax(lang)) {
            const msg = `"${lang}" is not a valid language code.`;
            context.logger.fatal(msg);
            throw new schematics_1.SchematicsException(msg);
        }
    }
    return options;
}
/**
 * The schematic factory addLanguage.
 * @param optionsFromCommandline contains the languages to be added.
 */
function addLanguage(optionsFromCommandline) {
    return (host, context) => {
        const options = setupOptions(optionsFromCommandline, host, context);
        const languagesToAdd = options.parsedLanguages
            .filter(lang => lang !== options.i18nLocale);
        const configurationAdditions = languagesToAdd
            .map(lang => common_2.addLanguageConfigurationToProject(options, lang));
        const startScriptAdditions = languagesToAdd
            .map(lang => common_2.addStartScriptToPackageJson(options, lang));
        return schematics_1.chain([
            schematics_1.branchAndMerge(schematics_1.chain([
                addLanguagesToXliffmergeConfiguration(options, host, languagesToAdd),
                changeExtractScriptInPackageJson(options, host),
                ...configurationAdditions,
                ...startScriptAdditions
            ]))
        ])(host, context);
    };
}
exports.addLanguage = addLanguage;
//# sourceMappingURL=index.js.map