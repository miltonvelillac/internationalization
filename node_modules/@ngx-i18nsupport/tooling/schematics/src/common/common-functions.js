"use strict";
/**
 * Functions shared between the schematics.
 **/
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_core_1 = require("../../schematics-core");
/**
 * Check syntax of language code.
 * (pattern copied from xliffmerge)
 * Must be compatible with XML Schema type xsd:language.
 * Pattern: [a-zA-Z]{1,8}((-|_)[a-zA-Z0-9]{1,8})*
 * @param lang the language code
 * @return true, if valid, false otherwise
 */
function isValidLanguageSyntax(lang) {
    const pattern = /^[a-zA-Z]{1,8}([-_][a-zA-Z0-9]{1,8})*$/;
    return pattern.test(lang);
}
exports.isValidLanguageSyntax = isValidLanguageSyntax;
function fullExtractScript(options) {
    const defaultLanguage = options.i18nLocale;
    const i18nFormat = options.i18nFormat;
    const languagesBlankSeparated = options.languages ? options.languages.replace(/,/g, ' ') : '';
    const languagesCommandLineArgument = (options.useComandlineForLanguages) ? ' ' + languagesBlankSeparated : '';
    const localeDir = options.localePath;
    const configFilePath = 'xliffmerge.json';
    return `ng xi18n --i18n-format ${i18nFormat} --output-path ${localeDir} --i18n-locale ${defaultLanguage}\
 && xliffmerge --profile ${configFilePath}${languagesCommandLineArgument}`;
}
exports.fullExtractScript = fullExtractScript;
/**
 * returns the build configuration to be set.
 */
function buildConfigurationForLanguage(options, language) {
    return {
        aot: true,
        outputPath: `dist/${options.project}-${language}`,
        i18nFile: `${options.genDir}/messages.${language}.xlf`,
        i18nFormat: options.i18nFormat,
        i18nLocale: language
    };
}
exports.buildConfigurationForLanguage = buildConfigurationForLanguage;
/**
 * returns the serve configuration to be set.
 */
function serveConfigurationForLanguage(options, language) {
    return {
        browserTarget: `${options.project}:build:${language}`
    };
}
exports.serveConfigurationForLanguage = serveConfigurationForLanguage;
/**
 * Add a start script.
 * Script will be named 'start-<language>' or 'start-<project>-<language'.
 * @param options options options containing project etc.
 * @param language language to be added.
 */
function addStartScriptToPackageJson(options, language) {
    return (host, context) => {
        const scriptName = (options.isDefaultProject) ? `start-${language}` : `start-${options.project}-${language}`;
        schematics_core_1.addScriptToPackageJson(host, scriptName, startScript(options, language));
        context.logger.info(`added npm script to start app for language ${language}, run "npm run ${scriptName}"`);
        return host;
    };
}
exports.addStartScriptToPackageJson = addStartScriptToPackageJson;
/**
 * returns the start script to be added.
 */
function startScript(options, language) {
    if (options.isDefaultProject) {
        return `ng serve --configuration=${language}`;
    }
    else {
        return `ng serve ${options.project} --configuration=${language}`;
    }
}
/**
 * Add the build and serve configuration for a given language to angular.json.
 * @param options options containing project etc.
 * @param language the language to be added.
 */
function addLanguageConfigurationToProject(options, language) {
    return (host, context) => {
        schematics_core_1.addArchitectBuildConfigurationToProject(host, context, options.project, language, buildConfigurationForLanguage(options, language));
        context.logger.info(`added build configuration for language "${language}" to project "${options.project}"`);
        schematics_core_1.addArchitectServeConfigurationToProject(host, context, options.project, language, serveConfigurationForLanguage(options, language));
        context.logger.info(`added serve configuration for language "${language}" to project "${options.project}"`);
        return host;
    };
}
exports.addLanguageConfigurationToProject = addLanguageConfigurationToProject;
//# sourceMappingURL=common-functions.js.map